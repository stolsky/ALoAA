{"version":3,"file":"math-extras.js","sources":["../src/pointExtras.ts","../src/rectangleExtras.ts","../src/index.ts"],"sourcesContent":["import type { IPointData } from '@pixi/core';\nimport { Point, ObservablePoint } from '@pixi/core';\n\nconst mixins: any = {\n    /**\n     * Adds `other` to `this` point and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method add\n     * @memberof PIXI.Point#\n     * @param {IPointData} other - The point to add to `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `outPoint` reference or a new Point, with the result of the addition.\n     */\n    /**\n     * Adds `other` to `this` point and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method add\n     * @memberof PIXI.ObservablePoint#\n     * @param {IPointData} other - The point to add to `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `outPoint` reference or a new Point, with the result of the addition.\n     */\n    add<T extends IPointData>(other: IPointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            (outPoint as any) = new Point();\n        }\n        outPoint.x = this.x + other.x;\n        outPoint.y = this.y + other.y;\n\n        return outPoint;\n    },\n\n    /**\n     * Subtracts `other` from `this` point and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method subtract\n     * @memberof PIXI.Point#\n     * @param {IPointData} other - The point to subtract to `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `outPoint` reference or a new Point, with the result of the subtraction.\n     */\n    /**\n     * Subtracts `other` from `this` point and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method subtract\n     * @memberof PIXI.ObservablePoint#\n     * @param {IPointData} other - The point to subtract to `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `outPoint` reference or a new Point, with the result of the subtraction.\n     */\n    subtract<T extends IPointData>(other: IPointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            (outPoint as any) = new Point();\n        }\n        outPoint.x = this.x - other.x;\n        outPoint.y = this.y - other.y;\n\n        return outPoint;\n    },\n\n    /**\n     * Multiplies component-wise `other` and `this` points and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method multiply\n     * @memberof PIXI.Point#\n     * @param {IPointData} other - The point to multiply with `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `outPoint` reference or a new Point, with the component-wise multiplication.\n     */\n    /**\n     * Multiplies component-wise `other` and `this` points and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method multiply\n     * @memberof PIXI.ObservablePoint#\n     * @param {IPointData} other - The point to multiply with `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `outPoint` reference or a new Point, with the component-wise multiplication.\n     */\n    multiply<T extends IPointData>(other: IPointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            (outPoint as any) = new Point();\n        }\n        outPoint.x = this.x * other.x;\n        outPoint.y = this.y * other.y;\n\n        return outPoint;\n    },\n\n    /**\n     * Multiplies each component of `this` point with the number `scalar` and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method multiplyScalar\n     * @memberof PIXI.Point#\n     * @param {number} scalar - The number to multiply both components of `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `outPoint` reference or a new Point, with the multiplication.\n     */\n    /**\n     * Multiplies each component of `this` point with the number `scalar` and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method multiplyScalar\n     * @memberof PIXI.ObservablePoint#\n     * @param {number} scalar - The number to multiply both components of `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `outPoint` reference or a new Point, with the multiplication.\n     */\n    multiplyScalar<T extends IPointData>(scalar: number, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            (outPoint as any) = new Point();\n        }\n        outPoint.x = this.x * scalar;\n        outPoint.y = this.y * scalar;\n\n        return outPoint;\n    },\n\n    /**\n     * Computes the dot product of `other` with `this` point.\n     * The dot product is the sum of the products of the corresponding components of two vectors.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method dot\n     * @memberof PIXI.Point#\n     * @param {IPointData} other - The other point to calculate the dot product with `this`.\n     * @returns {number} The result of the dot product. This is an scalar value.\n     */\n    /**\n     * Computes the dot product of `other` with `this` point.\n     * The dot product is the sum of the products of the corresponding components of two vectors.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method dot\n     * @memberof PIXI.ObservablePoint#\n     * @param {IPointData} other - The other point to calculate the dot product with `this`.\n     * @returns {number} The result of the dot product. This is an scalar value.\n     */\n    dot(other: IPointData): number\n    {\n        return (this.x * other.x) + (this.y * other.y);\n    },\n\n    /**\n     * Computes the cross product of `other` with `this` point.\n     * Given two linearly independent R3 vectors a and b, the cross product, a × b (read \"a cross b\"),\n     * is a vector that is perpendicular to both a and b, and thus normal to the plane containing them.\n     * While cross product only exists on 3D space, we can assume the z component of 2D to be zero and\n     * the result becomes a vector that will only have magnitude on the z axis.\n     *\n     * This function returns the z component of the cross product of the two points.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method cross\n     * @memberof PIXI.Point#\n     * @param {IPointData} other - The other point to calculate the cross product with `this`.\n     * @returns {number} The z component of the result of the cross product.\n     */\n    /**\n     * Computes the cross product of `other` with `this` point.\n     * Given two linearly independent R3 vectors a and b, the cross product, a × b (read \"a cross b\"),\n     * is a vector that is perpendicular to both a and b, and thus normal to the plane containing them.\n     * While cross product only exists on 3D space, we can assume the z component of 2D to be zero and\n     * the result becomes a vector that will only have magnitude on the z axis.\n     *\n     * This function returns the z component of the cross product of the two points.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method cross\n     * @memberof PIXI.ObservablePoint#\n     * @param {IPointData} other - The other point to calculate the cross product with `this`.\n     * @returns {number} The z component of the result of the cross product.\n     */\n    cross(other: IPointData): number\n    {\n        /*\n         * Returns the magnitude of the vector that would result\n         * from a regular 3D cross product of the input vectors,\n         * taking their Z values implicitly as 0\n         * (i.e. treating the 2D space as a plane in the 3D space).\n         * The 3D cross product will be perpendicular to that plane,\n         * and thus have 0 X & Y components\n         * (thus the scalar returned is the Z value of the 3D cross product vector).\n         */\n        return (this.x * other.y) - (this.y * other.x);\n    },\n\n    /**\n     * Computes a normalized version of `this` point.\n     *\n     * A normalized vector is a vector of magnitude (length) 1\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method normalize\n     * @memberof PIXI.Point#\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The normalized point.\n     */\n    /**\n     * Computes a normalized version of `this` point.\n     *\n     * A normalized vector is a vector of magnitude (length) 1\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method normalize\n     * @memberof PIXI.ObservablePoint#\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The normalized point.\n     */\n    normalize<T extends IPointData>(outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            (outPoint as any) = new Point();\n        }\n        const magnitude = Math.sqrt((this.x * this.x) + (this.y * this.y));\n\n        outPoint.x = this.x / magnitude;\n        outPoint.y = this.y / magnitude;\n\n        return outPoint;\n    },\n\n    /**\n     * Computes the magnitude of this point (Euclidean distance from 0, 0).\n     *\n     * Defined as the square root of the sum of the squares of each component.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method magnitude\n     * @memberof PIXI.Point#\n     * @returns {number} The magnitude (length) of the vector.\n     */\n    /**\n     * Computes the magnitude of this point (Euclidean distance from 0, 0).\n     *\n     * Defined as the square root of the sum of the squares of each component.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method magnitude\n     * @memberof PIXI.ObservablePoint#\n     * @returns {number} The magnitude (length) of the vector.\n     */\n    magnitude(): number\n    {\n        return Math.sqrt((this.x * this.x) + (this.y * this.y));\n    },\n\n    /**\n     * Computes the square magnitude of this point.\n     * If you are comparing the lengths of vectors, you should compare the length squared instead\n     * as it is slightly more efficient to calculate.\n     *\n     * Defined as the sum of the squares of each component.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method magnitudeSquared\n     * @memberof PIXI.Point#\n     * @returns {number} The magnitude squared (length squared) of the vector.\n     */\n    /**\n     * Computes the square magnitude of this point.\n     * If you are comparing the lengths of vectors, you should compare the length squared instead\n     * as it is slightly more efficient to calculate.\n     *\n     * Defined as the sum of the squares of each component.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method magnitudeSquared\n     * @memberof PIXI.ObservablePoint#\n     * @returns {number} The magnitude squared (length squared) of the vector.\n     */\n    magnitudeSquared(): number\n    {\n        return (this.x * this.x) + (this.y * this.y);\n    },\n\n    /**\n     * Computes vector projection of `this` on `onto`.\n     *\n     * Imagine a light source, parallel to `onto`, above `this`.\n     * The light would cast rays perpendicular to `onto`.\n     * `this.project(onto)` is the shadow cast by `this` on the line defined by `onto` .\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method project\n     * @memberof PIXI.Point#\n     * @param {IPointData} onto - A non zero vector describing a line on which to project `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `this` on `onto` projection.\n     */\n    /**\n     * Computes vector projection of `this` on `onto`.\n     *\n     * Imagine a light source, parallel to `onto`, above `this`.\n     * The light would cast rays perpendicular to `onto`.\n     * `this.project(onto)` is the shadow cast by `this` on the line defined by `onto` .\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method project\n     * @memberof PIXI.ObservablePoint#\n     * @param {IPointData} onto - A non zero vector describing a line on which to project `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `this` on `onto` projection.\n     */\n    project<T extends IPointData>(onto: IPointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            (outPoint as any) = new Point();\n        }\n        // Math says: a Projected over b = [(a·b) / (b·b)] * b;\n        const normalizedScalarProjection = ((this.x * onto.x) + (this.y * onto.y)) / ((onto.x * onto.x) + (onto.y * onto.y));\n\n        outPoint.x = onto.x * normalizedScalarProjection;\n        outPoint.y = onto.y * normalizedScalarProjection;\n\n        return outPoint;\n    },\n\n    /**\n     * Reflects `this` vector off of a plane orthogonal to `normal`.\n     * `normal` is not normalized during this process. Consider normalizing your `normal` before use.\n     *\n     * Imagine a light source bouncing onto a mirror.\n     * `this` vector is the light and `normal` is a vector perpendicular to the mirror.\n     * `this.reflect(normal)` is the reflection of `this` on that mirror.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method reflect\n     * @memberof PIXI.Point#\n     * @param {IPointData} normal - The normal vector of your reflecting plane.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The reflection of `this` on your reflecting plane.\n     */\n    /**\n     * Reflects `this` vector off of a plane orthogonal to `normal`.\n     * `normal` is not normalized during this process. Consider normalizing your `normal` before use.\n     *\n     * Imagine a light source bouncing onto a mirror.\n     * `this` vector is the light and `normal` is a vector perpendicular to the mirror.\n     * `this.reflect(normal)` is the reflection of `this` on that mirror.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method reflect\n     * @memberof PIXI.ObservablePoint#\n     * @param {IPointData} normal - The normal vector of your reflecting plane.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The reflection of `this` on your reflecting plane.\n     */\n    reflect<T extends IPointData>(normal: IPointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            (outPoint as any) = new Point();\n        }\n\n        // Given an incident vector i and a normal vector n, returns the reflection vector r = i - 2 * dot(i, n) * n\n\n        const dotProduct = (this.x * normal.x) + (this.y * normal.y);\n\n        outPoint.x = this.x - (2 * dotProduct * normal.x);\n        outPoint.y = this.y - (2 * dotProduct * normal.y);\n\n        return outPoint;\n    }\n};\n\nObject.assign(Point.prototype, mixins);\nObject.assign(ObservablePoint.prototype, mixins);\n","import { Rectangle } from '@pixi/core';\n\n/**\n * Determines whether the `other` Rectangle is contained within `this` Rectangle object.\n * Rectangles that occupy the same space are considered to be containing each other.\n * Rectangles without area (width or height equal to zero) can't contain anything,\n * not even other arealess rectangles.\n *\n * _Note: Only available with **@pixi/math-extras**._\n * @method containsRect\n * @memberof PIXI.Rectangle#\n * @param {Rectangle} other - The Rectangle to fit inside `this`.\n * @returns {boolean} A value of `true` if `this` Rectangle contains `other`; otherwise `false`.\n */\nRectangle.prototype.containsRect = function containsRect(other: Rectangle): boolean\n{\n    if (other.width <= 0 || other.height <= 0)\n    {\n        return other.x > this.x && other.y > this.y && other.right < this.right && other.bottom < this.bottom;\n    }\n\n    return other.x >= this.x && other.y >= this.y && other.right <= this.right && other.bottom <= this.bottom;\n};\n\n/**\n * Accepts `other` Rectangle and returns true if the given Rectangle is equal to `this` Rectangle.\n *\n * _Note: Only available with **@pixi/math-extras**._\n * @method equals\n * @memberof PIXI.Rectangle#\n * @param {Rectangle} other - The Rectangle to compare with `this`\n * @returns {boolean} Returns true if all `x`, `y`, `width`, and `height` are equal.\n */\nRectangle.prototype.equals = function equals(other: Rectangle): boolean\n{\n    if (other === this)\n    {\n        return true;\n    }\n\n    return other && this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;\n};\n\n/**\n * If the area of the intersection between the Rectangles `other` and `this` is not zero,\n * returns the area of intersection as a Rectangle object. Otherwise, return an empty Rectangle\n * with its properties set to zero.\n * Rectangles without area (width or height equal to zero) can't intersect or be intersected\n * and will always return an empty rectangle with its properties set to zero.\n *\n * _Note: Only available with **@pixi/math-extras**._\n * @method intersection\n * @memberof PIXI.Rectangle#\n * @param {Rectangle} other - The Rectangle to intersect with `this`.\n * @param {Rectangle} [outRect] - A Rectangle object in which to store the value,\n * optional (otherwise will create a new Rectangle).\n * @returns {Rectangle} The intersection of `this` and `other`.\n */\nRectangle.prototype.intersection = function intersection<T extends Rectangle>(other: Rectangle, outRect?: T): T\n{\n    if (!outRect)\n    {\n        (outRect as any) = new Rectangle();\n    }\n\n    const x0 = this.x < other.x ? other.x : this.x;\n    const x1 = this.right > other.right ? other.right : this.right;\n\n    if (x1 <= x0)\n    {\n        outRect.x = outRect.y = outRect.width = outRect.height = 0;\n\n        return outRect;\n    }\n\n    const y0 = this.y < other.y ? other.y : this.y;\n    const y1 = this.bottom > other.bottom ? other.bottom : this.bottom;\n\n    if (y1 <= y0)\n    {\n        outRect.x = outRect.y = outRect.width = outRect.height = 0;\n\n        return outRect;\n    }\n\n    outRect.x = x0;\n    outRect.y = y0;\n    outRect.width = x1 - x0;\n    outRect.height = y1 - y0;\n\n    return outRect;\n};\n\n/**\n * Adds `this` and `other` Rectangles together to create a new Rectangle object filling\n * the horizontal and vertical space between the two rectangles.\n *\n * _Note: Only available with **@pixi/math-extras**._\n * @method union\n * @memberof PIXI.Rectangle#\n * @param {Rectangle} other - The Rectangle to unite with `this`.\n * @param {Rectangle} [outRect] - A Rectangle object in which to store the value,\n * optional (otherwise will create a new Rectangle).\n * @returns {Rectangle} The union of `this` and `other`.\n */\nRectangle.prototype.union = function union<T extends Rectangle>(other: Rectangle, outRect?: T): T\n{\n    if (!outRect)\n    {\n        (outRect as any) = new Rectangle();\n    }\n\n    const x1 = Math.min(this.x, other.x);\n    const x2 = Math.max(this.x + this.width, other.x + other.width);\n    const y1 = Math.min(this.y, other.y);\n    const y2 = Math.max(this.y + this.height, other.y + other.height);\n\n    outRect.x = x1;\n    outRect.y = y1;\n    outRect.width = x2 - x1;\n    outRect.height = y2 - y1;\n\n    return outRect;\n};\n","/// <reference path=\"../global.d.ts\" />\nimport './pointExtras';\nimport './rectangleExtras';\n\nimport type { IPointData } from '@pixi/core';\nimport { Point } from '@pixi/core';\n\n/**\n * The idea of a relative epsilon comparison is to find the difference between the two numbers,\n * and see if it is less than `Math.EPSILON`.\n *\n * _Note: Only available with **@pixi/math-extras**._\n * @param {number} a - First floating number to compare.\n * @param {number} b - Second floating number to compare.\n * @returns {boolean} Returns `true` if the difference between the values is less than `Math.EPSILON`; otherwise `false`.\n */\nexport function floatEqual(a: number, b: number): boolean;\n/**\n * The idea of a relative epsilon comparison is to find the difference between the two numbers,\n * and see if it is less than a given epsilon.\n * A good epsilon would be the N% of the largest of the two values or `Math.EPSILON`.\n *\n * _Note: Only available with **@pixi/math-extras**._\n * @memberof PIXI\n * @param {number} a - First floating number to compare.\n * @param {number} b - Second floating number to compare.\n * @param {number} epsilon - The epsilon to compare to.\n * The larger the epsilon, the easier for the numbers to be considered equals.\n * @returns {boolean} Returns `true` if the difference between the values is less than the given epsilon;\n * otherwise `false`.\n */\nexport function floatEqual(a: number, b: number, epsilon: number): boolean;\nexport function floatEqual(a: number, b: number, epsilon: number = Number.EPSILON): boolean\n{\n    if (a === b)\n    {\n        return true;\n    }\n\n    const diff = Math.abs(a - b);\n\n    return diff < epsilon;\n}\n\n/**\n * Generic line or segment intersection.\n * A line can intersect outside the two points defining it, the segment can't.\n * @param aStart - First point of the first line.\n * @param aEnd - Second point of the first line.\n * @param bStart - First point of the second line.\n * @param bEnd - Second point of the second line.\n * @param isLine - Set to true if you want Line (unbounded) intersection.\n * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n * optional (otherwise will create a new Point).\n * @returns {IPointData} The point where the lines/segments intersect or a `NaN` Point.\n */\nfunction genericLineIntersection<T extends IPointData>(\n    aStart: IPointData,\n    aEnd: IPointData,\n    bStart: IPointData,\n    bEnd: IPointData,\n    isLine: boolean,\n    outPoint?: T): T\n{\n    if (!outPoint)\n    {\n        (outPoint as any) = new Point();\n    }\n\n    const dxa = aEnd.x - aStart.x;\n    const dya = aEnd.y - aStart.y;\n    const dxb = bEnd.x - bStart.x;\n    const dyb = bEnd.y - bStart.y;\n\n    // In order to find the position of the intersection in respect to the line segments, we can define lines\n    // in terms of first degree Bézier parameters, and find the two parameters `ua` and `ub` for the two lines to touch.\n    // both `ua` and `ub` formula share the same denominator so it is only calculated once.\n\n    const denominator = ((dyb * dxa) - (dxb * dya));\n\n    // If lines are parallel or overlapping, the intersection can be nowhere or everywhere... NaN.\n    if (floatEqual(denominator, 0))\n    {\n        outPoint.x = NaN;\n        outPoint.y = NaN;\n\n        return outPoint;\n    }\n\n    // ua is the factor of line a where the intersection occurs. ub is the factor of line b where the intersection occurs.\n    const ua = ((dxb * (aStart.y - bStart.y)) - (dyb * (aStart.x - bStart.x))) / denominator;\n    const ub = ((dxa * (aStart.y - bStart.y)) - (dya * (aStart.x - bStart.x))) / denominator;\n\n    // Line intersection extends beyond the bounds of the segment.\n    // The intersection is inside the segments if 0.0 ≤ ua ≤ 1.0 and 0.0 ≤ ub ≤ 1.0\n    if (!isLine && (ua < 0 || ua > 1 || ub < 0 || ub > 1))\n    {\n        outPoint.x = NaN;\n        outPoint.y = NaN;\n\n        return outPoint;\n    }\n\n    outPoint.x = aStart.x + (ua * dxa);\n    outPoint.y = bStart.y + (ub * dyb);\n\n    return outPoint;\n}\n\n/**\n * Computes the point where non-coincident and non-parallel Lines intersect.\n * Coincident or parallel lines return a `NaN` point `{x: NaN, y: NaN}`.\n * The intersection point may land outside the extents of the lines.\n *\n * _Note: Only available with **@pixi/math-extras**._\n * @param aStart - First point of the first line.\n * @param aEnd - Second point of the first line.\n * @param bStart - First point of the second line.\n * @param bEnd - Second point of the second line.\n * @returns {IPointData} The point where the lines intersect.\n */\nexport function lineIntersection(aStart: IPointData, aEnd: IPointData, bStart: IPointData, bEnd: IPointData): Point;\n/**\n * Computes the point where non-coincident and non-parallel Lines intersect.\n * Coincident or parallel lines return a `NaN` point `{x: NaN, y: NaN}`.\n * The intersection point may land outside the extents of the lines.\n *\n * _Note: Only available with **@pixi/math-extras**._\n * @memberof PIXI\n * @param aStart - First point of the first line.\n * @param aEnd - Second point of the first line.\n * @param bStart - First point of the second line.\n * @param bEnd - Second point of the second line.\n * @param {IPointData} outPoint - A Point-like object in which to store the value,\n * optional (otherwise will create a new Point).\n * @returns {IPointData} The point where the lines intersect or a `NaN` Point.\n */\nexport function lineIntersection\n<T extends IPointData>(aStart: IPointData, aEnd: IPointData, bStart: IPointData, bEnd: IPointData, outPoint: T): T;\nexport function lineIntersection\n<T extends IPointData>(aStart: IPointData, aEnd: IPointData, bStart: IPointData, bEnd: IPointData, outPoint?: T): T\n{\n    return genericLineIntersection(aStart, aEnd, bStart, bEnd, true, outPoint);\n}\n\n/**\n * Computes the point where non-coincident and non-parallel segments intersect.\n * Coincident, parallel or non-intersecting segments return a `NaN` point `{x: NaN, y: NaN}`.\n * The intersection point must land inside the extents of the segments or return a `NaN` Point.\n *\n * _Note: Only available with **@pixi/math-extras**._\n * @param aStart - Starting point of the first segment.\n * @param aEnd - Ending point of the first segment.\n * @param bStart - Starting point of the second segment.\n * @param bEnd - Ending point of the second segment.\n * @returns {IPointData} The point where the segments intersect.\n */\nexport function segmentIntersection(aStart: IPointData, aEnd: IPointData, bStart: IPointData, bEnd: IPointData): Point;\n/**\n * Computes the point where non-coincident and non-parallel segments intersect.\n * Coincident, parallel or non-intersecting segments return a `NaN` point `{x: NaN, y: NaN}`.\n * The intersection point must land inside the extents of the segments or return a `NaN` Point.\n *\n * _Note: Only available with **@pixi/math-extras**._\n * @memberof PIXI\n * @param aStart - Starting point of the first segment.\n * @param aEnd - Ending point of the first segment.\n * @param bStart - Starting point of the second segment.\n * @param bEnd - Ending point of the second segment.\n * @param {IPointData} outPoint - A Point-like object in which to store the value,\n * optional (otherwise will create a new Point).\n * @returns {IPointData} The point where the segments intersect or a `NaN` Point.\n */\nexport function segmentIntersection\n<T extends IPointData>(aStart: IPointData, aEnd: IPointData, bStart: IPointData, bEnd: IPointData, outPoint: T): T;\nexport function segmentIntersection\n<T extends IPointData>(aStart: IPointData, aEnd: IPointData, bStart: IPointData, bEnd: IPointData, outPoint?: T): T\n{\n    return genericLineIntersection(aStart, aEnd, bStart, bEnd, false, outPoint);\n}\n"],"names":["Point","ObservablePoint","Rectangle"],"mappings":"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"}